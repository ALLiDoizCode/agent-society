# Story 2.4: Dynamic SPSP Request Handler (Server)

## Status

Done

## Story

**As an** agent developer,
**I want** to handle incoming SPSP requests and respond with fresh parameters,
**so that** I can provide unique payment destinations to requesters.

## Acceptance Criteria

1. `handleSpspRequests(generator: () => SpspInfo | Promise<SpspInfo>): Subscription` method added to `NostrSpspServer`
2. Method subscribes to kind:23194 events addressed to the agent's pubkey
3. Incoming requests are decrypted using NIP-44
4. Generator function is called to produce fresh SpspInfo for each request
5. Response is encrypted and published as kind:23195 event
6. Unit tests verify decryption, generator invocation, and response encryption

## Tasks / Subtasks

- [x] Task 1: Create parseSpspRequest parser function (AC: 3)
  - [x] Add `parseSpspRequest()` to `packages/core/src/events/parsers.ts`
  - [x] Validate event kind is 23194
  - [x] Decrypt content using NIP-44 with recipient's secret key and sender's pubkey
  - [x] Parse JSON to `SpspRequest` interface
  - [x] Validate `requestId` and `timestamp` fields
  - [x] Throw `InvalidEventError` for malformed/invalid requests
  - [x] Add unit tests for parser function

- [x] Task 2: Create buildSpspResponseEvent builder function (AC: 5)
  - [x] Add `buildSpspResponseEvent()` to `packages/core/src/events/builders.ts`
  - [x] Accept `SpspResponse` payload, `senderPubkey`, and `secretKey` as parameters
  - [x] Encrypt payload using NIP-44 with sender's (original requester's) pubkey
  - [x] Create kind:23195 event with encrypted content
  - [x] Add `p` tag with sender pubkey for routing
  - [x] Optionally add `e` tag referencing original request event ID
  - [x] Sign event with recipient's secret key
  - [x] Add unit tests for builder function

- [x] Task 3: Update events module exports (AC: 1)
  - [x] Export `parseSpspRequest` from `packages/core/src/events/index.ts`
  - [x] Export `buildSpspResponseEvent` from `packages/core/src/events/index.ts`
  - [x] Export from `packages/core/src/index.ts`

- [x] Task 4: Implement handleSpspRequests method (AC: 1, 2, 3, 4, 5)
  - [x] Method signature: `handleSpspRequests(generator: () => SpspInfo | Promise<SpspInfo>): Subscription`
  - [x] Derive own pubkey from secretKey using `getPublicKey()`
  - [x] Create subscription filter: `{ kinds: [SPSP_REQUEST_KIND], '#p': [myPubkey] }`
  - [x] Use `pool.subscribeMany()` to subscribe to relays
  - [x] On incoming event: decrypt, parse, call generator, encrypt response, publish
  - [x] Return `Subscription` object with `unsubscribe()` method that closes the subscription

- [x] Task 5: Implement request handling logic (AC: 3, 4, 5)
  - [x] For each incoming kind:23194 event:
    - [x] Extract sender pubkey from event.pubkey
    - [x] Decrypt using `parseSpspRequest()`
    - [x] Call `await Promise.resolve(generator())` to get fresh `SpspInfo` (supports sync and async)
    - [x] Build `SpspResponse` with requestId from request
    - [x] Build encrypted kind:23195 event using `buildSpspResponseEvent()`
    - [x] Publish response to relays using `pool.publish()`
  - [x] Handle decryption/parse errors gracefully (log and continue)

- [x] Task 6: Handle errors gracefully (AC: 3, 4, 5)
  - [x] Catch decryption errors silently (invalid requests are ignored)
  - [x] Catch generator errors and skip that request (don't crash subscription)
  - [x] Catch publish errors and continue processing other requests
  - [x] Never throw from subscription callback (would kill the subscription)

- [x] Task 7: Write unit tests for handleSpspRequests happy path (AC: 1, 2, 3, 4, 5, 6)
  - [x] Test method exists and returns Subscription
  - [x] Test subscribes to kind:23194 events with correct filter
  - [x] Test decrypts incoming request using NIP-44
  - [x] Test calls generator function for each request
  - [x] Test works with synchronous generator function
  - [x] Test works with async generator function (returns Promise)
  - [x] Test encrypts response with NIP-44
  - [x] Test publishes kind:23195 response event
  - [x] Test response includes correct requestId
  - [x] Test response includes 'p' tag with original sender

- [x] Task 8: Write unit tests for encryption/decryption (AC: 3, 5, 6)
  - [x] Test request is correctly decrypted
  - [x] Test response is correctly encrypted for sender
  - [x] Test malformed encrypted content is handled gracefully
  - [x] Test round-trip: client request -> server response -> client decrypt

- [x] Task 9: Write unit tests for Subscription lifecycle (AC: 1, 6)
  - [x] Test unsubscribe() closes the pool subscription
  - [x] Test no more events processed after unsubscribe
  - [x] Test multiple calls to unsubscribe are safe

- [x] Task 10: Write unit tests for error handling (AC: 6)
  - [x] Test handles InvalidEventError from parse gracefully
  - [x] Test handles generator throwing error gracefully
  - [x] Test handles publish failure gracefully
  - [x] Test continues processing after individual request failures

## Dev Notes

### Previous Story Insights
[Source: docs/stories/2.3.story.md#dev-agent-record]

From Story 2.3 (Dynamic SPSP Request - Client):
- Package uses ESM (`"type": "module"`) - use `.js` extension in imports
- TypeScript strict mode is enabled
- 180 tests currently pass in core package
- Test helpers cast through `unknown` for `VerifiedEvent` type: `as unknown as VerifiedEvent`
- `NostrSpspClient.requestSpspInfo()` shows client-side request/response pattern
- `buildSpspRequestEvent()` demonstrates encrypted event building with NIP-44
- `parseSpspResponse()` demonstrates encrypted event parsing with NIP-44
- `SpspTimeoutError` exists for timeout scenarios
- `crypto.randomUUID()` used for request ID generation
- Subscription filter uses `'#p': [pubkey]` for tagged event filtering
- `pool.subscribeMany()` called with filter directly (not wrapped in array)
- `Promise.any()` pattern used for relay publishing confirmation

### Project Structure
[Source: docs/architecture/9-source-tree.md]

Files to create/modify for this story:
```
packages/core/src/
├── spsp/
│   ├── NostrSpspServer.ts              # Add handleSpspRequests method (modify)
│   └── NostrSpspServer.test.ts         # Add new tests (modify)
├── events/
│   ├── builders.ts                     # Add buildSpspResponseEvent (modify)
│   ├── builders.test.ts                # Add builder tests (modify)
│   ├── parsers.ts                      # Add parseSpspRequest (modify)
│   ├── parsers.test.ts                 # Add parser tests (modify)
│   └── index.ts                        # Add exports (modify)
├── index.ts                            # Add exports (modify)
└── types.ts                            # SpspRequest, SpspResponse already exist
```

### Data Models
[Source: docs/architecture/4-data-models.md#43-spsprequest, #44-spspresponse]
[Source: packages/core/src/types.ts:33-55]

**SpspRequest (kind:23194):**
```typescript
export interface SpspRequest {
  /** Unique request identifier for correlation */
  requestId: string;
  /** Unix timestamp of the request */
  timestamp: number;
}
```

**SpspResponse (kind:23195):**
```typescript
export interface SpspResponse {
  /** Matching request identifier */
  requestId: string;
  /** ILP address to send payment to */
  destinationAccount: string;
  /** Base64-encoded shared secret for STREAM protocol */
  sharedSecret: string;
}
```

**Subscription interface:**
```typescript
export interface Subscription {
  /** Stops receiving updates and closes the underlying relay subscription */
  unsubscribe(): void;
}
```

### Event Kind Constants
[Source: packages/core/src/constants.ts]

Constants already exist:
```typescript
export const SPSP_REQUEST_KIND = 23194;
export const SPSP_RESPONSE_KIND = 23195;
```

### NIP-44 Encryption with nostr-tools
[Source: docs/architecture/3-tech-stack.md, docs/stories/2.3.story.md]

**nostr-tools provides NIP-44 encryption via `nip44` module:**
```typescript
import { nip44 } from 'nostr-tools';
import { getPublicKey } from 'nostr-tools/pure';

// Get conversation key for encryption/decryption
const conversationKey = nip44.getConversationKey(secretKey, otherPubkey);

// Encrypt payload (for response to sender)
const encrypted = nip44.encrypt(JSON.stringify(payload), conversationKey);

// Decrypt payload (incoming request from sender)
const decrypted = nip44.decrypt(encryptedContent, conversationKey);
const payload = JSON.parse(decrypted);
```

**Deriving public key from secret key:**
```typescript
import { getPublicKey } from 'nostr-tools/pure';

const pubkey = getPublicKey(secretKey); // Returns hex string
```

### Dynamic SPSP Handshake Flow (Server Perspective)
[Source: docs/architecture/7-core-workflows.md#72-dynamic-spsp-handshake]

```
1. Server calls handleSpspRequests(generator)
2. Server subscribes for kind:23194 events with '#p' tag = own pubkey
3. [Client sends encrypted request - covered in Story 2.3]
4. Server receives kind:23194 event via subscription
5. Server decrypts request using NIP-44 (sender pubkey from event.pubkey)
6. Server calls generator() to get fresh SpspInfo
7. Server creates SpspResponse with requestId from request
8. Server encrypts response using NIP-44 (for sender pubkey)
9. Server publishes kind:23195 event with 'p' tag = sender pubkey
10. [Client receives and decrypts - covered in Story 2.3]
```

### Event Structure for SPSP Response (kind:23195)
[Source: docs/stories/2.3.story.md, docs/architecture/4-data-models.md]

```typescript
const event = {
  kind: 23195,               // SPSP_RESPONSE_KIND
  content: encrypted,         // NIP-44 encrypted SpspResponse JSON
  tags: [
    ['p', senderPubkey],     // Tag original requester for routing
    ['e', requestEventId],   // Reference original request (optional)
  ],
  created_at: Math.floor(Date.now() / 1000),
  // pubkey and sig added by finalizeEvent()
};
```

### Event Structure for SPSP Request (kind:23194) - For Parsing
[Source: docs/stories/2.3.story.md, packages/core/src/events/builders.ts:72-99]

```typescript
// Incoming request event structure
{
  kind: 23194,
  content: encrypted,        // NIP-44 encrypted SpspRequest JSON
  pubkey: senderPubkey,      // Who sent the request
  tags: [
    ['p', recipientPubkey],  // Our pubkey (recipient)
  ],
  created_at: timestamp,
}
```

### nostr-tools SimplePool Subscription API
[Source: packages/core/src/spsp/NostrSpspClient.ts:165]
[Source: packages/core/src/discovery/NostrPeerDiscovery.ts]

**SimplePool.subscribeMany() for subscriptions:**
```typescript
import { SimplePool, type SubCloser } from 'nostr-tools/pool';
import type { Filter } from 'nostr-tools/filter';

const filter: Filter = {
  kinds: [SPSP_REQUEST_KIND],
  '#p': [myPubkey],          // Events tagged with my pubkey
};

const sub = pool.subscribeMany(relayUrls, filter, {
  onevent(event) {
    // Handle incoming event
  },
  oneose() {
    // End of stored events (optional)
  },
});

// Later: close subscription
sub.close();
```

**Note:** `subscribeMany` is called with `filter` directly, NOT `[filter]`.

### Existing NostrSpspServer Implementation
[Source: packages/core/src/spsp/NostrSpspServer.ts]

Current class structure:
```typescript
export class NostrSpspServer {
  private readonly relayUrls: string[];
  private readonly secretKey: Uint8Array;
  private readonly pool: SimplePool;

  constructor(relayUrls: string[], secretKey: Uint8Array, pool?: SimplePool) {
    this.relayUrls = relayUrls;
    this.secretKey = secretKey;
    this.pool = pool ?? new SimplePool();
  }

  async publishSpspInfo(info: SpspInfo): Promise<void> { ... }

  // Add: handleSpspRequests(generator: () => SpspInfo | Promise<SpspInfo>): Subscription
}
```

The class already has `secretKey` stored, which is needed for:
1. Deriving own pubkey (for subscription filter)
2. Decrypting incoming requests
3. Signing outgoing responses

### Error Handling
[Source: docs/architecture/11-error-handling-strategy.md]

**Error scenarios for handleSpspRequests:**
- Invalid/malformed request → silently ignore (don't crash subscription)
- Decryption fails → silently ignore (may be encrypted for different recipient)
- Generator throws → silently ignore, continue with other requests
- Publish fails → silently ignore, request will timeout on client side

**CRITICAL:** Never throw from subscription callback - this would kill the subscription and stop processing all requests. Wrap all logic in try-catch.

### Coding Standards
[Source: docs/architecture/12-coding-standards.md]

| Element | Convention | Example |
|---------|------------|---------|
| Files | PascalCase for class files | `NostrSpspServer.ts` |
| Classes | PascalCase | `NostrSpspServer` |
| Methods | camelCase | `handleSpspRequests` |
| Constants | UPPER_SNAKE_CASE | `SPSP_REQUEST_KIND` |

**Critical Rules:**
- Never use `any` - use `unknown` and type guards
- Always mock SimplePool in tests - no live relay dependencies
- Export from index.ts - all public APIs exported from package index
- Use nostr-tools types - don't redefine event types
- NEVER log private keys or shared secrets

### Testing
[Source: docs/architecture/13-test-strategy-and-standards.md]

**Framework:** Vitest 1.x

**Mocking pool.subscribeMany():**
```typescript
import { vi } from 'vitest';

const mockSub = { close: vi.fn() };

// Simulate incoming request event
vi.mocked(mockPool.subscribeMany).mockImplementation((relays, filter, callbacks) => {
  // Capture the callbacks for later use
  setTimeout(() => {
    callbacks.onevent?.(mockRequestEvent);
  }, 10);
  return mockSub;
});
```

**Mocking NIP-44 for testing:**
```typescript
import { vi } from 'vitest';

// Use real nip44 for round-trip tests, or mock for isolation
// The existing tests in 2.3 show patterns for mocking encryption/decryption
```

**Test Requirements:**
- Follow AAA pattern (Arrange, Act, Assert)
- Mock all SimplePool and nip44 calls
- Test success and error paths
- >80% coverage for new functionality
- Test Subscription lifecycle (subscribe, process, unsubscribe)

### Security Considerations
[Source: docs/architecture/14-security.md]

- Use NIP-44 encryption for SPSP request/response (AC: 3, 5)
- NEVER log private keys, shared secrets, or decrypted payloads
- Validate event signatures are valid (nostr-tools does this by default)
- Handle decryption failures gracefully (don't expose failure reasons)
- Don't trust event.pubkey without verifying signature

### Rate Limiting Note

**Rate limiting is intentionally left to the application layer.** This library does not implement rate limiting for incoming SPSP requests because:

1. **Relay-level filtering**: Nostr relays can implement their own rate limiting per pubkey
2. **Application-specific needs**: Different applications have different throughput requirements
3. **Flexibility**: Applications may want to rate limit by sender pubkey, IP, or other criteria

**Recommendations for implementers:**
- Consider implementing rate limiting in your generator function
- Track request counts per sender pubkey if needed
- Use a token bucket or sliding window algorithm for smooth rate limiting
- Log excessive request patterns for monitoring (but never log secrets)

Example rate limiting in generator:
```typescript
const requestCounts = new Map<string, number>();

server.handleSpspRequests(async () => {
  // Application-level rate limiting can be implemented here
  return generateSpspInfo();
});
```

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5

### File List

| File | Action | Description |
|------|--------|-------------|
| packages/core/src/events/parsers.ts | Modified | Added `parseSpspRequest()` function for decrypting and parsing kind:23194 events |
| packages/core/src/events/parsers.test.ts | Modified | Added 13 tests for `parseSpspRequest()` covering happy path and error cases |
| packages/core/src/events/builders.ts | Modified | Added `buildSpspResponseEvent()` function for building encrypted kind:23195 events |
| packages/core/src/events/builders.test.ts | Modified | Added 9 tests for `buildSpspResponseEvent()` covering encryption and round-trip |
| packages/core/src/events/index.ts | Modified | Added exports for `parseSpspRequest` and `buildSpspResponseEvent` |
| packages/core/src/index.ts | Modified | Added exports for `parseSpspRequest` and `buildSpspResponseEvent` to package root |
| packages/core/src/spsp/NostrSpspServer.ts | Modified | Added `handleSpspRequests()` method with full request handling logic |
| packages/core/src/spsp/NostrSpspServer.test.ts | Modified | Added 22 tests covering happy path, encryption, subscription lifecycle, and error handling |

### Debug Log References
N/A - No issues encountered during development.

### Completion Notes
- All 10 tasks completed successfully
- 220 tests pass in core package (40 new tests added)
- Lint passes with no errors
- `subscribeMany()` API requires filter directly (NOT wrapped in array) - dev notes were correct
- Silent error handling implemented throughout to prevent subscription callback from throwing

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-06 | 0.1 | Initial story draft | SM |
| 2026-02-06 | 0.2 | Added async generator support, rate limiting documentation | SM |
| 2026-02-06 | 0.3 | Implementation complete | Dev Agent (Claude Opus 4.5) |

## QA Results

### Review Date: 2026-02-06

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Implementation is **excellent**. The code demonstrates strong architectural patterns with clean separation of concerns between event parsing/building (in `events/`) and server logic (in `spsp/`). The `handleSpspRequests` method correctly implements the full SPSP dynamic handshake flow:

1. Derives own pubkey from secretKey for subscription filtering
2. Subscribes to kind:23194 events tagged with own pubkey
3. Decrypts incoming requests using NIP-44
4. Calls the generator (sync or async) to produce fresh SpspInfo
5. Builds encrypted kind:23195 response with requestId correlation
6. Publishes response to relays

Error handling is particularly well-implemented - all errors are silently caught to prevent subscription callback from throwing, which would kill the subscription. This is critical for long-running server processes.

### Refactoring Performed

None required. The implementation follows established patterns from prior stories (2.2, 2.3) and is well-structured.

### Compliance Check

- Coding Standards: ✓ TypeScript strict mode, no `any` usage, PascalCase classes, camelCase methods
- Project Structure: ✓ Files in correct locations per source-tree.md
- Testing Strategy: ✓ AAA pattern, mocked SimplePool, >80% coverage
- All ACs Met: ✓ All 6 acceptance criteria verified (see trace below)

### Improvements Checklist

- [x] All code follows established patterns (no changes needed)
- [x] Tests comprehensive (40 new tests added, 220 total passing)
- [x] Error handling robust (silent catch in subscription callback)
- [x] Exports properly configured in index.ts files
- [ ] Consider adding JSDoc @example tags to `handleSpspRequests()` method (nice-to-have)
- [ ] Consider documenting rate-limiting patterns in README (nice-to-have, mentioned in dev notes)

### Security Review

**PASS** - No security concerns identified.

- NIP-44 encryption used correctly for request/response payloads
- Secrets (secretKey, sharedSecret) never logged
- Invalid/malformed requests silently ignored (no information leakage)
- Event pubkey trusted only after processing through nostr-tools

### Performance Considerations

**PASS** - No performance concerns for library scope.

- Async/await used appropriately
- `Promise.any()` for publish confirmation (fast path)
- Generator supports both sync and async patterns
- Rate limiting correctly delegated to application layer (documented)

### Files Modified During Review

None - implementation quality is high, no refactoring performed.

### Gate Status

Gate: PASS → docs/qa/gates/2.4-dynamic-spsp-request-handler-server.yml

### Requirements Traceability (Given-When-Then)

**AC1: handleSpspRequests method signature**
- Given: NostrSpspServer instance
- When: handleSpspRequests(generator) is called
- Then: Returns Subscription object with unsubscribe() method
- Tests: "returns Subscription object", "unsubscribe() closes the pool subscription"

**AC2: Subscribes to kind:23194 events**
- Given: Server with secretKey
- When: handleSpspRequests is called
- Then: Creates subscription filter `{ kinds: [23194], '#p': [myPubkey] }`
- Tests: "subscribes to kind:23194 events with correct filter"

**AC3: Decrypts requests using NIP-44**
- Given: Encrypted kind:23194 event
- When: Event received via subscription
- Then: Decrypts using NIP-44 with sender pubkey
- Tests: "decrypts incoming request using NIP-44", "request is correctly decrypted", 13 parser tests

**AC4: Generator invoked for fresh SpspInfo**
- Given: Valid decrypted request
- When: Processing request
- Then: Generator function called (sync or async)
- Tests: "calls generator function for each request", "works with synchronous generator", "works with async generator"

**AC5: Encrypted response published**
- Given: SpspInfo from generator
- When: Building response
- Then: Creates encrypted kind:23195 event with p tag and optional e tag
- Tests: "encrypts response with NIP-44", "publishes kind:23195 response event", "response includes 'p' tag", 9 builder tests

**AC6: Unit tests verify flow**
- Given: Test suite
- When: Running vitest
- Then: All scenarios covered
- Tests: 40 new tests (22 server + 13 parser + 9 builder tests) = 220 total passing

### Recommended Status

✓ Ready for Done - All acceptance criteria met, comprehensive test coverage, clean implementation.

